package com.linkedin.metadata.kafka.hook.notification.change;

import com.datahub.authentication.Authentication;
import com.datahub.notification.NotificationTemplateType;
import com.datahub.notification.provider.EntityNameProvider;
import com.datahub.notification.provider.SettingsProvider;
import com.google.common.collect.ImmutableSet;
import com.linkedin.common.AuditStamp;
import com.linkedin.common.urn.Urn;
import com.linkedin.common.urn.UrnUtils;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.entity.client.EntityClient;
import com.linkedin.event.notification.NotificationRecipient;
import com.linkedin.event.notification.NotificationRequest;
import com.linkedin.events.metadata.ChangeType;
import com.linkedin.gms.factory.auth.SystemAuthenticationFactory;
import com.linkedin.gms.factory.entity.RestliEntityClientFactory;
import com.linkedin.gms.factory.entityregistry.EntityRegistryFactory;
import com.linkedin.metadata.Constants;
import com.linkedin.metadata.event.EventProducer;
import com.linkedin.metadata.graph.GraphClient;
import com.linkedin.metadata.kafka.hook.notification.BaseMclNotificationGenerator;
import com.linkedin.metadata.kafka.hook.notification.NotificationScenarioType;
import com.linkedin.metadata.models.AspectSpec;
import com.linkedin.metadata.models.registry.EntityRegistry;
import com.linkedin.metadata.timeline.data.ChangeCategory;
import com.linkedin.metadata.timeline.data.ChangeEvent;
import com.linkedin.metadata.timeline.data.ChangeOperation;
import com.linkedin.metadata.timeline.differ.Aspect;
import com.linkedin.metadata.timeline.differ.AspectDifferRegistry;
import com.linkedin.metadata.timeline.differ.AspectDiffer;
import com.linkedin.metadata.utils.GenericRecordUtils;
import com.linkedin.mxe.MetadataChangeLog;
import com.linkedin.mxe.SystemMetadata;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Import;
import org.springframework.stereotype.Component;

import static com.linkedin.metadata.kafka.hook.notification.NotificationUtils.*;


/**
 * A {@link com.linkedin.metadata.kafka.hook.notification.MclNotificationGenerator} which is driven
 * by Change Events generated by Aspect Differs.
 *
 * This generator supports generating notifications for the the following aspects:
 *
 *    - owners changes
 *    - glossary term changes (entity)
 *    - global tag changes (entity)
 *    - tag proposal changes
 *    - term proposal changes
 *
 * Coming Soon:
 *
 *    - schema changes
 *    - domain changes
 *    - description changes
 *    - [advanced] assertion results
 *    - [advanced] test results
 *    - [advanced] incident changes [Already Supported By Incident Notification Generator!]
 *    - [advanced] new statistics
 *    - [advanced] domains added or removed, terms and glossaries added or removed.
 */
@Slf4j
@Component
@Import({
    AspectDifferRegistry.class,
    EntityRegistryFactory.class,
    RestliEntityClientFactory.class,
    SystemAuthenticationFactory.class
})
public class EntityChangeNotificationGenerator extends BaseMclNotificationGenerator {

  /**
   * The list of aspects that are supported for generating semantic change events.
   */
  private static final Set<String> SUPPORTED_ASPECT_NAMES = ImmutableSet.of(
      Constants.GLOBAL_TAGS_ASPECT_NAME,
      Constants.GLOSSARY_TERMS_ASPECT_NAME,
      Constants.OWNERSHIP_ASPECT_NAME,
      Constants.DEPRECATION_ASPECT_NAME,
      Constants.SCHEMA_METADATA_ASPECT_NAME,
      Constants.EDITABLE_SCHEMA_METADATA_ASPECT_NAME,
      Constants.DOMAINS_ASPECT_NAME
  );
  /**
   * The list of aspects that are supported for generating semantic change events.
   */
  private static final Set<String> SUPPORTED_ENTITY_NAMES = ImmutableSet.of(
      Constants.DATASET_ENTITY_NAME,
      Constants.CHART_ENTITY_NAME,
      Constants.DASHBOARD_ENTITY_NAME,
      Constants.CONTAINER_ENTITY_NAME,
      Constants.DATA_FLOW_ENTITY_NAME,
      Constants.DATA_JOB_ENTITY_NAME,
      Constants.DOMAIN_ENTITY_NAME,
      Constants.TAG_ENTITY_NAME,
      Constants.DOMAIN_ENTITY_NAME
  );
  /**
   * The list of aspects that are supported for generating semantic change events.
   */
  private static final Set<ChangeType> SUPPORTED_CHANGE_TYPES = ImmutableSet.of(
      ChangeType.CREATE,
      ChangeType.UPSERT
  );

  private final EntityNameProvider _entityNameProvider;
  private final AspectDifferRegistry _aspectDifferRegistry;
  private final EntityRegistry _entityRegistry;

  public EntityChangeNotificationGenerator(
      @Nonnull final AspectDifferRegistry aspectDifferRegistry,
      @Nonnull final EntityRegistry entityRegistry,
      @Nonnull final EventProducer eventProducer,
      @Nonnull final EntityClient entityClient,
      @Nonnull final GraphClient graphClient,
      @Nonnull final Authentication systemAuthentication) {
    super(eventProducer, entityClient, graphClient, new SettingsProvider(entityClient, systemAuthentication), systemAuthentication);
    _entityNameProvider = new EntityNameProvider(entityClient, systemAuthentication);
    _aspectDifferRegistry = Objects.requireNonNull(aspectDifferRegistry);
    _entityRegistry = Objects.requireNonNull(entityRegistry);
  }

  @Override
  public void generate(@Nonnull MetadataChangeLog logEvent) {
    if (isEligibleForProcessing(logEvent)) {
      // Steps:
      // 1. Parse the old and new aspect.
      // 2. Find and invoke a differ.
      // 3. Sink the output of the differ to a specific PDL change event.
      final AspectSpec aspectSpec = _entityRegistry
          .getEntitySpec(logEvent.getEntityType())
          .getAspectSpec(logEvent.getAspectName());

      assert aspectSpec != null;

      final RecordTemplate fromAspect = logEvent.getPreviousAspectValue() != null
          ? GenericRecordUtils.deserializeAspect(
          logEvent.getPreviousAspectValue().getValue(),
          logEvent.getPreviousAspectValue().getContentType(),
          aspectSpec)
          : null;

      final RecordTemplate toAspect = logEvent.getAspect() != null
          ? GenericRecordUtils.deserializeAspect(
          logEvent.getAspect().getValue(),
          logEvent.getAspect().getContentType(),
          aspectSpec)
          : null;

      final List<ChangeEvent> changeEvents = generateChangeEvents(
          logEvent.getEntityUrn(),
          logEvent.getEntityType(),
          logEvent.getAspectName(),
          createAspect(fromAspect, logEvent.getPreviousSystemMetadata()),
          createAspect(toAspect, logEvent.getSystemMetadata()),
          logEvent.getCreated()
      );

      trySendEntityChangeNotifications(logEvent, changeEvents);
    }
  }

  private void trySendEntityChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    switch (logEvent.getAspectName()) {
      case Constants.GLOBAL_TAGS_ASPECT_NAME:
        trySendTagChangeNotifications(logEvent, changeEvents);
        break;
      case Constants.GLOSSARY_TERMS_ASPECT_NAME:
        trySendGlossaryTermChangeNotifications(logEvent, changeEvents);
        break;
      case Constants.OWNERSHIP_ASPECT_NAME:
        trySendOwnershipChangeNotifications(logEvent, changeEvents);
        break;
      case Constants.DEPRECATION_ASPECT_NAME:
        trySendDeprecationChangeNotifications(logEvent, changeEvents);
        break;
      case Constants.DOMAINS_ASPECT_NAME:
        trySendDomainChangeNotifications(logEvent, changeEvents);
        break;
      case Constants.SCHEMA_METADATA_ASPECT_NAME:
      case Constants.EDITABLE_SCHEMA_METADATA_ASPECT_NAME:
        trySendDatasetSchemaFieldChangeNotifications(logEvent, changeEvents);
        trySendSchemaFieldTagChangeNotifications(logEvent, changeEvents);
        trySendSchemaFieldGlossaryTermChangeNotifications(logEvent, changeEvents);
        break;
      default:
        log.warn(String.format("Found supported aspect that did not generate any notifications: %s", logEvent.getAspectName()));
        return;
    }
  }

  private void trySendTagChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
      List<Urn> addedUrns = changeEvents.stream()
          .filter(changeEvent -> ChangeCategory.TAG.equals(changeEvent.getCategory()))
          .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
          .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
          .collect(Collectors.toList());

      if (addedUrns.size() > 0) {
        sendEntityChangeNotification(
            NotificationScenarioType.ENTITY_TAG_CHANGE,
            logEvent.getCreated().getActor(),
            "added",
            "Tag(s)",
            addedUrns,
            logEvent.getEntityUrn(),
            null,
            null
        );
      }

      List<Urn> removedUrns = changeEvents.stream()
          .filter(changeEvent -> ChangeCategory.TAG.equals(changeEvent.getCategory()))
          .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
          .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
          .collect(Collectors.toList());

      if (removedUrns.size() > 0) {
        sendEntityChangeNotification(
            NotificationScenarioType.ENTITY_TAG_CHANGE,
            logEvent.getCreated().getActor(),
            "removed",
            "Tag(s)",
            removedUrns,
            logEvent.getEntityUrn(),
            null,
            null
        );
      }
  }

  private void trySendGlossaryTermChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.GLOSSARY_TERM.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_GLOSSARY_TERM_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "Glossary Term(s)",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.GLOSSARY_TERM.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_GLOSSARY_TERM_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "Glossary Term(s)",
          removedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }
  }

  private void trySendOwnershipChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {

    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.OWNER.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_OWNER_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "owner(s)",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.OWNER.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {

      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_OWNER_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "owner(s)",
          removedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }
  }

  private void trySendDomainChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.DOMAIN.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_DOMAIN_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "Domain",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.DOMAIN.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_DOMAIN_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "Domain",
          removedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }
  }

  private void trySendDeprecationChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    long deprecationChangeEventCount = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.DEPRECATION.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.MODIFY.equals(changeEvent.getOperation()))
        .count();
    if (deprecationChangeEventCount > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_DEPRECATION_CHANGE,
          logEvent.getCreated().getActor(),
          "updated",
          "deprecation",
          null,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }
  }

  private void trySendDatasetSchemaFieldChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.TECHNICAL_SCHEMA.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.DATASET_SCHEMA_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "schema field(s)",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.TECHNICAL_SCHEMA.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.DATASET_SCHEMA_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "schema field(s)",
          removedUrns,
          logEvent.getEntityUrn(),
          "",
          null
      );
    }
  }

  private void trySendSchemaFieldTagChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.TAG.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_TAG_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "Tag(s)",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.TAG.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_TAG_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "Tag(s)",
          removedUrns,
          logEvent.getEntityUrn(),
          "",
          null
      );
    }
  }

  private void trySendSchemaFieldGlossaryTermChangeNotifications(final MetadataChangeLog logEvent, final List<ChangeEvent> changeEvents) {
    List<Urn> addedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.GLOSSARY_TERM.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.ADD.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (addedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_GLOSSARY_TERM_CHANGE,
          logEvent.getCreated().getActor(),
          "added",
          "Glossary Term(s)",
          addedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }

    List<Urn> removedUrns = changeEvents.stream()
        .filter(changeEvent -> ChangeCategory.GLOSSARY_TERM.equals(changeEvent.getCategory()))
        .filter(changeEvent -> ChangeOperation.REMOVE.equals(changeEvent.getOperation()))
        .map(changeEvent -> UrnUtils.getUrn(changeEvent.getModifier()))
        .collect(Collectors.toList());

    if (removedUrns.size() > 0) {
      sendEntityChangeNotification(
          NotificationScenarioType.ENTITY_GLOSSARY_TERM_CHANGE,
          logEvent.getCreated().getActor(),
          "removed",
          "Glossary Term(s)",
          removedUrns,
          logEvent.getEntityUrn(),
          null,
          null
      );
    }
  }

  private void sendEntityChangeNotification(
      final NotificationScenarioType notificationScenarioType,
      final Urn actorUrn,
      final String operation,
      final String modifierType,
      @Nullable final List<Urn> modifierUrns,
      final Urn entityUrn,
      @Nullable final String subResourceType,
      @Nullable final String subResource
  ) {
    // 1. Determine who to send to.
    Set<NotificationRecipient> recipients = new HashSet<>(buildRecipients(notificationScenarioType, entityUrn));

    if (recipients.isEmpty()) {
      return;
    }

    // 2. Build request.
    final String entityName = _entityNameProvider.getName(entityUrn);
    final Map<String, String> templateParams = new HashMap<>();
    templateParams.put("entityName", entityName);
    templateParams.put("entityPath", generateEntityPath(entityUrn));
    templateParams.put("entityType", getEntityType(entityUrn));
    templateParams.put("operation", operation);
    templateParams.put("modifierType", modifierType);
    templateParams.put("modifierCount", modifierUrns == null ? "0" : String.valueOf(modifierUrns.size()));
    templateParams.put("actorUrn", actorUrn.toString());


    if (modifierUrns != null) {
      for (int i = 0; i < modifierUrns.size() && i < 3; i++) {
        final Urn modifierUrn = modifierUrns.get(i);
        final String modifierName = _entityNameProvider.getName(modifierUrn);
        templateParams.put(String.format("modifier%sName", i), modifierName);
        templateParams.put(String.format("modifier%sPath", i), generateEntityPath(modifierUrn));
      }
    }

    if (subResource != null && subResourceType != null) {
      templateParams.put("subResourceType", subResourceType);
      templateParams.put("subResource", subResource);
    }

    final NotificationRequest notificationRequest = buildNotificationRequest(
        NotificationTemplateType.BROADCAST_ENTITY_CHANGE.name(),
        templateParams,
        recipients
    );

    // 3. Send request.
    log.info(String.format("Broadcasting entity change notification request for entity %s, notification type %s", entityUrn,
        notificationScenarioType));
    sendNotificationRequest(notificationRequest);
  }

  private  <T extends RecordTemplate> List<ChangeEvent> generateChangeEvents(
      @Nonnull final Urn urn,
      @Nonnull final String entityName,
      @Nonnull final String aspectName,
      @Nonnull final Aspect from,
      @Nonnull final Aspect to,
      @Nonnull AuditStamp auditStamp
  ) {
    final List<AspectDiffer<T>> aspectDiffers = _aspectDifferRegistry.getAspectDiffers(aspectName)
        .stream()
        .map(differ -> (AspectDiffer<T>) differ) // Note: Assumes that correct types have been registered for the aspect.
        .collect(Collectors.toList());
    final List<ChangeEvent> allChangeEvents = new ArrayList<>();
    for (AspectDiffer<T> aspectDiffer : aspectDiffers) {
      allChangeEvents.addAll(aspectDiffer.getChangeEvents(urn, entityName, aspectName, from, to, auditStamp));
    }
    return allChangeEvents;
  }

  private boolean isEligibleForProcessing(final MetadataChangeLog log) {
    return SUPPORTED_CHANGE_TYPES.contains(log.getChangeType())
        && SUPPORTED_ASPECT_NAMES.contains(log.getAspectName())
        && SUPPORTED_ENTITY_NAMES.contains(log.getEntityType());
  }

  private Aspect createAspect(@Nullable final RecordTemplate value, @Nullable final SystemMetadata systemMetadata) {
    return new Aspect(
        value,
        systemMetadata
    );
  }
}